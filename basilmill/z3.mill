package build.basilmill

import mill._
import api._
import javalib._
import mainargs._
import os.Path

trait Z3Module extends OfflineSupportModule, CoursierModule, JavaModule {

  val z3LibNames = List("libz3", "libz3java")
  val z3ArtifactTypes = Set(coursier.core.Type("so"), coursier.core.Type("dll"), coursier.core.Type("dylib"))

  /**
   * Fetches the required libraries for the given platform into the given destination directory.
   *
   * Returns the given destination directory path.
   */
  def fetchLibraries(resolver: CoursierModule.Resolver, ctx: TaskCtx)(dest: Path, platform: Platform) = {

    val soType = platform.os.libExtension
    val arch = platform.arch match {
      case Platform.X86_64 => "x64"
      case Platform.Aarch64 => "arm64"
    }

    z3LibNames.foreach(source => {
      val dep = Dep.parse(s"org.sosy-lab:javasmt-solver-z3:4.14.0;classifier=$source-$arch;type=$soType")

      val path =
        resolver.classpath(Seq(dep), artifactTypes = Some(z3ArtifactTypes))(using implicitly, ctx).head.path
      val newPath = dest / s"$source.$soType"

      os.copy(path, newPath)
    })

    dest
  }

  /** Installs the appropriate Z3 libraries for the current platform. */
  def install = Task {
    Platform.detect() match {
      case Right(x) => fetchLibraries(millResolver(), implicitly)(Task.dest, x)
      case Left(e) => Task.fail(e)
    }
  }

  override def prepareOffline(all: Flag) = Task.Command[Seq[PathRef]] {
    import Platform.*

    val supportedPlatforms = Set(Platform(X86_64, Linux), Platform(Aarch64, Mac))

    val doFetch = fetchLibraries(millResolver(), implicitly)
    val libDirs = supportedPlatforms.map(doFetch(Task.dest, _))

    libDirs.toSeq.map(PathRef(_))
  }

}
