Prog . Program ::= [Declaration] ;

terminator Declaration ";";

token BVTYPE ('b' 'v' digit+) ;

position token UserIdent '`' ((upper | letter | '_' | '#')(upper | letter | digit | ["_.$#"])*) '`';
position token BIdent ((upper | letter | '_')(upper | letter | digit | ["_.$#"])*) ;

position token LocalIdent '#' ((upper | letter | digit | ["_.$#"])+);
position token GlobalIdent '$' ((upper | letter | digit | ["_.$#"])+);

position token BlockIdent '%' ((upper | letter | digit | ["_.$#"])+);

separator BlockIdent ",";

position token ProcIdent '@' ((upper | letter | digit | ["_.$#"])+);

position token BeginList '[' ;
position token EndList ']' ;
position token BeginRec '{' ;
position token EndRec '}' ;

token Str '"' ((char - ["\"\\"]) | ('\\' ["\"\\tnrf"]))* '"' ;
token IntegerHex ('0' 'x' (digit | ["abcdef"])+);


token BitvectorHex (('0' 'x' (digit | ["abcdef"])+)) ;

comment "//" ;
comment "/*" "*/" ;

LetDecl . Declaration ::= "let" BIdent "=" MExpr ;
MemDecl . Declaration ::= "memory" GlobalIdent ":" Type ;
VarDecl . Declaration ::= "var" GlobalIdent ":" Type  ;

ThreadDecl . Declaration ::= "thread" AttrDefList ;

MSym . MExpr ::= Str;
BlockM . MExpr ::= Block ;

IntT . IntType ::= "int" ;
BoolT . BoolType ::= "bool" ;
MapT . MapType ::= "map" Type BeginList Type EndList ;
BVT . BVType ::= BVTYPE ;

rules Type ::= IntType | BoolType | MapType | BVType ; 

separator Expr "," ;

HexInt . IntVal ::= IntegerHex ;
DecInt . IntVal ::=  Integer ;

BV . BVVal ::=  IntVal ":" BVType ;

LittleEndian . Endian ::= "le" ;
BigEndian . Endian ::= "be" ;

terminator Statement ";";

Assign . Statement ::= LVar ":=" Expr ;

SLoad . Statement ::= LVar ":=" "load" Endian GlobalIdent Expr IntVal;
SStore . Statement ::= "store" Endian GlobalIdent Expr Expr IntVal;

NoOutParams . CallLVars ::= "";
LocalVars . CallLVars ::= "var" "(" [ LVar ] ")" ":=" ;
ListOutParams . CallLVars ::= "(" [ LVar ] ")" ":=";

DirectCall . Statement ::= CallLVars "call" ProcIdent "(" [Expr] ")" ;
IndirectCall . Statement ::= "indirect" "call" Expr ;

Assume . Statement ::= "assume" Expr ;
Assert . Statement ::= "assert" Expr ;

GoTo . Jump ::= "goto" "(" [BlockIdent] ")" ;
Unreachable . Jump ::= "unreachable" ;
Return . Jump ::= "return" "(" [Expr] ")" ;

LVarDef . LVar ::= LocalIdent ":" Type;
GlobalLVar . LVar ::= GlobalIdent ":" Type;

separator nonempty LVar "," ;

separator Block ";" ;

B . Block ::= "block" BlockIdent AttrDefList BeginList 
  [Statement] Jump
  EndList ;


IntAttr . AttributeItem ::= BIdent "="  IntVal;
BVAttr . AttributeItem ::= BIdent "=" BVVal;
ExprAttr . AttributeItem ::= BIdent "=" Expr;
StringAttr . AttributeItem ::= BIdent "=" Str ;
separator AttributeItem ";";

AttrDefListSome . AttrDefList ::= BeginRec [ AttributeItem ] EndRec ;
AttrDefListEmpty . AttrDefList ::= "" ;

Param . Params ::=  LocalIdent ":" Type ;
separator Params "," ;

ProcedureSig . ProcSig ::= "proc" ProcIdent "(" [Params] ")" "->" "(" [Params] ")"  ;
ProcedureDecl . ProcDef ::= ProcSig AttrDefList  ;
ProcedureDef  . ProcDef ::= ProcSig AttrDefList BeginList [Block] EndList  ;

Procedure . Declaration ::= ProcDef ;

_ . Expr ::= "(" Expr ")" ;


BVLiteral . Expr ::=  BVVal;
IntLiteral . Expr ::= IntVal;
TrueLiteral . Expr ::= "true" ;
FalseLiteral . Expr ::= "false" ;

LRVar . Expr ::= LocalIdent ":" Type;
GRVar . Expr ::= GlobalIdent ":" Type;


FunctionOp . Expr       ::= BIdent "(" [Expr] ")" ;
separator Expr ",";
