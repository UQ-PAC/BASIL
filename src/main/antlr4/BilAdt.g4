grammar BilAdt;

project : 'Project' OPEN_PAREN attrs COMMA sections COMMA memmap COMMA program CLOSE_PAREN EOF;

adt : exp
    | term
    | endian
    | unimplemented
    | list
    | tid
    | attr
    | num
    | quoteString
    ;

program : 'Program' OPEN_PAREN tid COMMA attrs COMMA subs CLOSE_PAREN ;

exp : OPEN_PAREN exp CLOSE_PAREN #expParen
    | 'Load' OPEN_PAREN memVar COMMA idx=exp COMMA endian COMMA size=num CLOSE_PAREN #load
    | op=BINOP OPEN_PAREN lhs=exp COMMA rhs=exp CLOSE_PAREN #binOp
    | op=UOP OPEN_PAREN exp CLOSE_PAREN #uOp
    | immVar #expImmVar
    | 'Int' OPEN_PAREN value=num COMMA size=num CLOSE_PAREN #expInt
    | cast #expCast
    | 'Extract' OPEN_PAREN hb=num COMMA lb=num COMMA exp CLOSE_PAREN #extract
    | 'Concat' OPEN_PAREN lhs=exp COMMA rhs=exp CLOSE_PAREN #concat
    ;

castImm : cast #castOpt
        | immVar #immOpt
        ;

cast : CAST OPEN_PAREN size=num COMMA exp CLOSE_PAREN;
store : 'Store' OPEN_PAREN memVar COMMA idx=exp COMMA value=exp COMMA endian COMMA size=num CLOSE_PAREN;
immVar : 'Var' OPEN_PAREN name=quoteString COMMA 'Imm' OPEN_PAREN size=num CLOSE_PAREN CLOSE_PAREN;
memVar : 'Var' OPEN_PAREN name=quoteString COMMA 'Mem' OPEN_PAREN addr_size=num COMMA value_size=num CLOSE_PAREN CLOSE_PAREN;

term : assign
     | jmp
     | sub
     ;

// Note that for call nodes, the cond is generated by the lifter but is not documented in the python_bap tool - Not sure why this is the case
jmps : 'Jmps' OPEN_PAREN OPEN_BRACKET (jmp (COMMA jmp)*)? CLOSE_BRACKET CLOSE_PAREN;
jmp : 'Call' OPEN_PAREN tid COMMA attrs COMMA cond=exp COMMA OPEN_PAREN callee=indirect COMMA returnTarget=direct? CLOSE_PAREN CLOSE_PAREN #indirectCall
    | 'Call' OPEN_PAREN tid COMMA attrs COMMA cond=exp COMMA OPEN_PAREN callee=direct COMMA returnTarget=direct? CLOSE_PAREN CLOSE_PAREN #directCall
    | 'Goto' OPEN_PAREN tid COMMA attrs COMMA cond=exp COMMA target=direct CLOSE_PAREN #gotoJmp
    ;

//basejmp : 'Jmp' OPEN_PAREN tid COMMA attrs COMMA cond=exp COMMA target=adt CLOSE_PAREN;

subs : 'Subs'  OPEN_PAREN OPEN_BRACKET (sub (COMMA sub)*)? CLOSE_BRACKET CLOSE_PAREN;
sub : 'Sub' OPEN_PAREN tid COMMA attrs COMMA name=quoteString COMMA args COMMA blks CLOSE_PAREN;

blks : 'Blks' OPEN_PAREN OPEN_BRACKET (blk (COMMA blk)*)? CLOSE_BRACKET CLOSE_PAREN;
blk : 'Blk' OPEN_PAREN tid COMMA attrs COMMA phis COMMA defs COMMA jmps CLOSE_PAREN;

args : 'Args' OPEN_PAREN OPEN_BRACKET (arg (COMMA arg)*)? CLOSE_BRACKET CLOSE_PAREN;
arg : 'Arg' OPEN_PAREN tid COMMA attrs COMMA lhs=immVar COMMA rhs=castImm COMMA intent CLOSE_PAREN;

attr : 'Attr' OPEN_PAREN lhs=quoteString COMMA rhs=quoteString CLOSE_PAREN;
attrs : 'Attrs' OPEN_PAREN OPEN_BRACKET (attr (COMMA attr)*)? CLOSE_BRACKET CLOSE_PAREN;

intent : 'In' OPEN_PAREN CLOSE_PAREN | 'Out' OPEN_PAREN CLOSE_PAREN | 'Both' OPEN_PAREN CLOSE_PAREN;

endian : ENDIAN OPEN_PAREN CLOSE_PAREN;

// 'Tid'(number, name)
tid : 'Tid' OPEN_PAREN id=tidId COMMA name=quoteString CLOSE_PAREN;

tidId : num
      | NUM_UNDERSCORE
      ;

defs : 'Defs' OPEN_PAREN OPEN_BRACKET (assign (COMMA assign)*)? CLOSE_BRACKET CLOSE_PAREN;
assign : 'Def' OPEN_PAREN tid COMMA attrs COMMA lhs=immVar COMMA rhs=exp CLOSE_PAREN #immDef
    | 'Def' OPEN_PAREN tid COMMA attrs COMMA lhs=memVar COMMA rhs=store CLOSE_PAREN #memDef
    ;

/* Unimportant ADTs - should be matched last */
phis : 'Phis' OPEN_PAREN list CLOSE_PAREN;
memmap : 'Memmap' OPEN_PAREN list CLOSE_PAREN;
sections : 'Sections' OPEN_PAREN list CLOSE_PAREN;

list : OPEN_BRACKET sequence CLOSE_BRACKET;
unimplemented : SYMBOL OPEN_PAREN sequence CLOSE_PAREN;
sequence : (adt (COMMA adt)*)?;
//phi : 'Phi' OPEN_PAREN tid COMMA attrs COMMA lhs=adt COMMA values=adt CLOSE_PAREN;

direct : 'Direct' OPEN_PAREN tid CLOSE_PAREN;

indirect : 'Indirect' OPEN_PAREN immVar CLOSE_PAREN;

//quoteString :  '"' ( ESCAPE | ~('"' | '\\' | '\n' | '\r') )+ '"' ;

num : DEC #numDec
    | HEX #numHex
    ;

BINOP : PLUS
      | MINUS
      | TIMES
      | DIVIDE
      | SDIVIDE
      | MOD
      | SMOD
      | LSHIFT
      | RSHIFT
      | ARSHIFT
      | AND
      | OR
      | XOR
      | EQ
      | NEQ
      | LT
      | LE
      | SLT
      | SLE
      ;

UOP : NEG | NOT;

CAST : UNSIGNED | SIGNED | HIGH | LOW;

UNSIGNED : 'UNSIGNED';
SIGNED : 'SIGNED';
HIGH : 'HIGH';
LOW : 'LOW';

// BinOp alternatives
PLUS     : 'PLUS';
MINUS    : 'MINUS';
TIMES    : 'TIMES';
DIVIDE   : 'DIVIDE';
SDIVIDE  : 'SDIVIDE';
MOD      : 'MOD';
SMOD     : 'SMOD';
LSHIFT   : 'LSHIFT';
RSHIFT   : 'RSHIFT';
ARSHIFT  : 'ARSHIFT';
AND      : 'AND';
OR       : 'OR';
XOR      : 'XOR';
EQ       : 'EQ';
NEQ      : 'NEQ';
LT       : 'LT';
LE       : 'LE';
SLT      : 'SLT';
SLE      : 'SLE';


// UnOp alternatives
NOT      : 'NOT';
NEG      : 'NEG';

ENDIAN : LITTLE_ENDIAN | BIG_ENDIAN;
LITTLE_ENDIAN : 'LittleEndian';
BIG_ENDIAN : 'BigEndian';

// Numbers and symbols
SYMBOL : ALPHA+;
ALPHA : [A-Za-z];
DEC : DIGIT+;
HEX : '0x'? HEXDIGIT+;
DIGIT : [0-9];
HEXDIGIT : [0-9a-fA-F];
NUM_UNDERSCORE : [0-9_]+;

// Delimiters
OPEN_PAREN : '(';
CLOSE_PAREN : ')';
COMMA : ',';
OPEN_BRACKET : '[';
CLOSE_BRACKET : ']';

quoteString : STRING;

// quoteStrings
ESCAPE : '\\' ( '"' | '\\' | 'n' | 'x' | '.');
STRING :  '"' ( ESCAPE | ~('"' | '\\' | '\n' | '\r') )+ '"' ;


// Ignored
NEWLINE : ('\r\n' | '\n') -> skip;
WHITESPACE : ' '+ -> skip;
COMMENT : '//' ~[\r\n]* -> skip;

