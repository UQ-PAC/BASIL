package analysis

import ir._
import analysis.BitVectorEval._
import util.Logger
import math.pow

/** Basic lattice
  */
trait Lattice[T]:

  type Element = T
  /** The bottom element of this lattice.
    */
  val bottom: T

  /** The top element of this lattice. Default: not implemented.
    */
  def top: T = ???

  /** The least upper bound of `x` and `y`.
    */
  def lub(x: T, y: T): T

  /** Returns true whenever `x` <= `y`.
    */
  def leq(x: T, y: T): Boolean = lub(x, y) == y // rarely used, but easy to implement :-)

//trait StridedInterval[+T]
//
//case class SI[T](s: T, l: T, u: T) extends StridedInterval[T] {
//  override def toString = s"SI $s [$l, $u]"
//}
//
//case object SIBottom extends StridedInterval[BitVecLiteral] {
//  override def toString = "SIBot"
//}

///**
// * SI class that represents a strided interval
// * s is the stride
// * l is the lower bound
// * u is the upper bound
// * [l, u] is the interval
// * [l, u] \ s is the set of values
// * 0[l,l] represents the singleton set {l}
// */
//class StridedIntervalLattice extends Lattice[StridedInterval[BitVecLiteral]] {
//  val lowestPossibleValue: BitVecLiteral = BitVecLiteral(0, 64)
//  val highestPossibleValue: BitVecLiteral = BitVecLiteral(Long.MaxValue - 1, 64)
//
//  override val bottom: StridedInterval[BitVecLiteral] = SIBottom
//  override def top: StridedInterval[BitVecLiteral] = SI(BitVecLiteral(1, 64), lowestPossibleValue, highestPossibleValue)
//
//  def gamma(x: StridedInterval[BitVecLiteral]): Set[BitVecLiteral] = x match {
//    case SIBottom => Set.empty
//    case SI(s, l, u) =>
//      bitVec_interval(l, u, s)
//  }
//
//  /** S1[L1, U1] join S2[L2, U2] -> gcd(S1, S2)[min(L1, L2), max(U1, U2)] */
//  override def lub(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    (x, y) match {
//      case (SIBottom, t) => t
//      case (t, SIBottom) => t
//      case (SI(s1, l1, u1), SI(s2, l2, u2)) =>
//        SI(bitVec_gcd(s1, s2), bitVec_min(l1, l2), bitVec_max(u1, u2))
//    }
//  }
//
//  /** S1[L1, U1] meet S2[L2, U2] -> gcd(S1, S2)[max(L1, L2), min(U1, U2)] */
//  def meet(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    (x, y) match {
//      case (SIBottom, t) => SIBottom
//      case (t, SIBottom) => SIBottom
//      case (SI(s1, l1, u1), SI(s2, l2, u2)) =>
//        SI(bitVec_gcd(s1, s2), bitVec_max(l1, l2), bitVec_min(u1, u2))
//    }
//  }
//
//  /** Addition
//   * Addition defined in page 6 Figure 2 of: https://dl.acm.org/doi/pdf/10.1145/1111542.1111560
//   * */
//  def add(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    (x, y) match {
//      case (SIBottom, t) => t
//      case (t, SIBottom) => t
//      case (SI(s1, l1, u1), SI(s2, l2, u2)) =>
//        val lbound = smt_bvadd(l1, l2)
//        val ubound = smt_bvadd(u1, u2)
//        val s = bitVec_gcd(s1, s2)
//        if (smt_bvsle(ubound, highestPossibleValue) == TrueLiteral && smt_bvsge(lbound, lowestPossibleValue) == TrueLiteral) {
//          SI(s, lbound, ubound)
//        } else {
//          throw new IllegalArgumentException(s"Addition overflow: $lbound, $ubound")
//        }
//    }
//  }
//
//  /** Unary Minus */
//  def unaryMinus(x: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    x match {
//      case SIBottom => SIBottom
//      case SI(s, l, u) =>
//        if (smt_bvcomp(l, u) == BitVecLiteral(1, 1) && (smt_bvcomp(l, lowestPossibleValue) == BitVecLiteral(1, 1) && smt_bvcomp(u, lowestPossibleValue) == BitVecLiteral(1, 1))) {
//          SI(BitVecLiteral(0, 64), lowestPossibleValue, lowestPossibleValue)
//        } else if (smt_bvcomp(l, lowestPossibleValue) == BitVecLiteral(0, 1)) {
//          SI(s, smt_bvneg(u), smt_bvneg(l))
//        }
//        else {
//          SI(BitVecLiteral(1, 64), lowestPossibleValue, highestPossibleValue)
//        }
//    }
//  }
//
//  /** Substraction */
//  def sub(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    add(x, unaryMinus(y))
//  }
//
//  /** Widen */
//  def widen(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    /* formula for widening:
//      given: s1[lb1, ub1] and s2[lb2, ub2]
//      then: gcd(s1, s2)[min(lb1, lb2), max(ub1, ub2)]
//      where: min(lb1, lb2) = lb1                  if lb1 <= lb2
//        and: min(lb1, lb2) = minPossibleValue     otherwise
//      where: max(ub1, ub2) = ub1                  if ub1 >= ub2
//        and: max(ub1, ub2) = maxPossibleValue     otherwise
//
//      assuming:
//        minPossibleValue = lowestPossibleValue
//        maxPossibleValue = highestPossibleValue + (lb - 1) mod s
//     */
//    (x, y) match {
//      case (SIBottom, t) => ???
//      case (t, SIBottom) => ???
//      case (SI(s1, l1, u1), SI(s2, l2, u2)) =>
//        val s = bitVec_gcd(s1, s2)
//        val l = if (smt_bvule(l1, l2) == TrueLiteral) l1 else lowestPossibleValue
//        val u = if (smt_bvuge(u1, u2) == TrueLiteral) u1 else smt_bvsmod(smt_bvadd(highestPossibleValue, smt_bvsub(l1, BitVecLiteral(1, 64))), s)
//        SI(s, l, u)
//    }
//  }
//
//  /**
//   * Calculating strided interval for a list of values using accumulative gcd.
//   * @param x the list of values
//   * @return the strided interval representing the values in the list
//   */
//  def valuesToSI(x: List[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    if (x.isEmpty) {
//      SIBottom
//    } else {
//      val l = bitVec_min(x)
//      val u = bitVec_max(x)
//      val initialStride = smt_bvsub(u, l)
//      val stride = x.foldLeft(initialStride) {
//          case (acc, v) => bitVec_gcd(smt_bvsub(v, l), acc)
//      }
//      SI(stride, l, u)
//    }
//  }
//}


trait StridedWrappedInterval

case class SI(s: BigInt, l: BigInt, u: BigInt, w: BigInt) extends StridedWrappedInterval {
  if (l == u) {
    require(s == 0)
  }
  override def toString = s"SASI $s [$l, $u] $w"
}

case object SIBottom extends StridedWrappedInterval {
  override def toString = "SASIBot"
}

// TOP is 1[0^w, 1^w]w
case object SITop extends StridedWrappedInterval {
  override def toString = "SASITop"
}

class SASILattice extends Lattice[StridedWrappedInterval] {
  val lowestPossibleValue: BigInt = 0
  val highestPossibleValue: BigInt = Long.MaxValue - 1

  override val bottom: StridedWrappedInterval = SIBottom

  override def top: StridedWrappedInterval = SITop

//  def gamma(x: StridedWrappedInterval): Set[BitVecLiteral] = x match {
//    case SIBottom => Set.empty
//    case SI(s, l, u, w) =>
//      if (s == BitVecLiteral(0, 64)) { // singleton set
//        Set(l)
//      } else {
//        bitVec_interval(l, u, s)
//      }
//  }

  def isSingleValue(x: StridedWrappedInterval): Boolean = x match {
    case SI(s, l, u, w) => s == 0 && l == u
    case _ => false
  }

  def modularPlus(a: BigInt, b: BigInt, w: BigInt): BigInt = {
    (a + b) mod BigInt(2).pow(w.toInt)
  }

  def modularMinus(a: BigInt, b: BigInt, w: BigInt): BigInt = {
    (a - b) mod BigInt(2).pow(w.toInt)
  }

  def modularLEQ(a: BigInt, b: BigInt, x: BigInt, w: BigInt): Boolean = {
    modularMinus(a, x, w) <= modularMinus(b, x, w)
  }

  def membershipFunction(v: BigInt, r: StridedWrappedInterval): Boolean = {
    r match {
      case SIBottom => false
      case SITop => true
      case SI(sr, lb, ub, w) =>
        modularLEQ(v, ub, lb, w) && (modularMinus(v, lb, w) mod sr) == 0
    }
  }

  def cardinalityFunction(r: StridedWrappedInterval, w: BigInt): BigInt = {
    r match {
      case SIBottom => 0
      case SITop => BigInt(2).pow(w.toInt)
      case SI(sr, lb, ub, w) => ((ub - lb + 1) / sr) // TODO: this may need to be a math.floor operation
    }
  }

  def orderingOperator(r: StridedWrappedInterval, t: StridedWrappedInterval): Boolean = {
    if (r == SITop && t != SITop) {
      false
    } else if (r == SIBottom || t == SITop) {
      true
    } else {
      (r, t) match {
        case (SI(sr, a, b, w1), SI(st, c, d, w2)) =>
          if ((a == c) && (b == d) && ((sr mod st) == 0)) {
            return true
          }
          membershipFunction(a, t) && membershipFunction(b, t) && (!membershipFunction(c, r) || !membershipFunction(d, r)) && ((a - c) mod st) == 0 && (sr mod st) == 0
        case _ => false
      }
    }
  }

  /** S1[L1, U1] join S2[L2, U2] -> gcd(S1, S2)[min(L1, L2), max(U1, U2)] */
  override def lub(r: StridedWrappedInterval, t: StridedWrappedInterval): StridedWrappedInterval = {
//    (s, t) match {
//      case (SIBottom, t) => t
//      case (t, SIBottom) => t
//      case (SI(a, b, u1, w1), SI(s2, c, d, w2)) =>
//        var u: BigInt = 0
//        var l: BigInt = 0
//        if (isSingleValue(s) && isSingleValue(t)) {
//          val si1_card = WCardMod()
//          val si2_card = WCardMod()
//          if (si1_card <= si2_card) {
//            l = a
//            u = d
//          } else {
//            l = c
//            u = b
//          }
//
//          SI(u - l, l, u, )
//        }
//    }

    (r, t) match {
      case (SI(sr, a, b, w1), SI(st, c, d, w2)) =>
        assert(w1 == w2)
        val w = w1 // TODO: should this be the largest?
        if (orderingOperator(r, t)) {
          return t
        }
        if (orderingOperator(t, r)) {
          return r
        }
        if (membershipFunction(a, t) && membershipFunction(b, t) && membershipFunction(c, r) && membershipFunction(d, r)) {
          return SITop
        }
        if (membershipFunction(c, r) && membershipFunction(b, t) && !membershipFunction(a, t) && !membershipFunction(d, r)) {
          return SI(sr.gcd(st).gcd(modularMinus(d, a, w)), a, d, w)
        }
        if (membershipFunction(a, t) && membershipFunction(d, r) && !membershipFunction(c, r) && !membershipFunction(b, t)) {
          return SI(sr.gcd(st).gcd(modularMinus(b, c, w)), c, b, w)
        }
        val sad = SI(sr.gcd(st).gcd(modularMinus(d, a, w)), a, d, w)
        val scb = SI(sr.gcd(st).gcd(modularMinus(b, c, w)), c, b, w)
        if (!membershipFunction(a, t) && !membershipFunction(d, r) && !membershipFunction(c, r) && !membershipFunction(b, t) && cardinalityFunction(sad, w) <= cardinalityFunction(scb, w)) {
          return sad
        }
        return scb
      case _ => ???
    }
  }

  def singletonSI(v: BigInt, w: BigInt): StridedWrappedInterval = {
    SI(0, v, v, w)
  }

  /**
   * s + t =
   *        BOT   if s = BOT or t = BOT
   *        gcd(s, t)(|a +w c, b +w d|)  if s = (|a, b|), t = (|c, d|) and #s + #t <= 2^w
   * @param s
   * @param t
   * @return
   */
  def add(s: StridedWrappedInterval, t: StridedWrappedInterval): StridedWrappedInterval = {
    (s, t) match {
      case (SIBottom, _) => SIBottom // TODO: is this correct?
      case (_, SIBottom) => SIBottom // TODO: is this correct?
      case (SI(ss, a, b, w1), SI(st, c, d, w2)) if (cardinalityFunction(s, w1) + cardinalityFunction(t, w2)) <= BigInt(2).pow(w1.toInt) =>
        assert(w1 == w2)
        return SI(ss.gcd(st), modularPlus(a, c, w1), modularPlus(b, d, w1), w1)
      case _ => SITop
    }
  }

  def add(s: StridedWrappedInterval, t: BigInt, w: BigInt): StridedWrappedInterval = {
    (s, t) match {
      case (SIBottom, _) => SIBottom // TODO: is this correct?
      case (SI(ss, a, b, w1), t) =>
        return add(s, singletonSI(t, w))
      case _ => SITop
    }
  }




//  /** S1[L1, U1] meet S2[L2, U2] -> gcd(S1, S2)[max(L1, L2), min(U1, U2)] */
//  def meet(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    (x, y) match {
//      case (SIBottom, t) => SIBottom
//      case (t, SIBottom) => SIBottom
//      case (SI(s1, l1, u1), SI(s2, l2, u2)) =>
//        SI(bitVec_gcd(s1, s2), bitVec_max(l1, l2), bitVec_min(u1, u2))
//    }
//  }
//
//  /** Addition
//   * Addition defined in page 6 Figure 2 of: https://dl.acm.org/doi/pdf/10.1145/1111542.1111560
//   * */
//  def add(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    (x, y) match {
//      case (SIBottom, t) => t
//      case (t, SIBottom) => t
//      case (SI(s1, l1, u1), SI(s2, l2, u2)) =>
//        val lbound = smt_bvadd(l1, l2)
//        val ubound = smt_bvadd(u1, u2)
//        val s = bitVec_gcd(s1, s2)
//        if (smt_bvsle(ubound, highestPossibleValue) == TrueLiteral && smt_bvsge(lbound, lowestPossibleValue) == TrueLiteral) {
//          SI(s, lbound, ubound)
//        } else {
//          throw new IllegalArgumentException(s"Addition overflow: $lbound, $ubound")
//        }
//    }
//  }
//
//  /** Unary Minus */
//  def unaryMinus(x: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    x match {
//      case SIBottom => SIBottom
//      case SI(s, l, u) =>
//        if (smt_bvcomp(l, u) == BitVecLiteral(1, 1) && (smt_bvcomp(l, lowestPossibleValue) == BitVecLiteral(1, 1) && smt_bvcomp(u, lowestPossibleValue) == BitVecLiteral(1, 1))) {
//          SI(BitVecLiteral(0, 64), lowestPossibleValue, lowestPossibleValue)
//        } else if (smt_bvcomp(l, lowestPossibleValue) == BitVecLiteral(0, 1)) {
//          SI(s, smt_bvneg(u), smt_bvneg(l))
//        }
//        else {
//          SI(BitVecLiteral(1, 64), lowestPossibleValue, highestPossibleValue)
//        }
//    }
//  }
//
//  /** Substraction */
//  def sub(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    add(x, unaryMinus(y))
//  }
//
//  /** Widen */
//  def widen(x: StridedInterval[BitVecLiteral], y: StridedInterval[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    /* formula for widening:
//      given: s1[lb1, ub1] and s2[lb2, ub2]
//      then: gcd(s1, s2)[min(lb1, lb2), max(ub1, ub2)]
//      where: min(lb1, lb2) = lb1                  if lb1 <= lb2
//        and: min(lb1, lb2) = minPossibleValue     otherwise
//      where: max(ub1, ub2) = ub1                  if ub1 >= ub2
//        and: max(ub1, ub2) = maxPossibleValue     otherwise
//
//      assuming:
//        minPossibleValue = lowestPossibleValue
//        maxPossibleValue = highestPossibleValue + (lb - 1) mod s
//     */
//    (x, y) match {
//      case (SIBottom, t) => ???
//      case (t, SIBottom) => ???
//      case (SI(s1, l1, u1), SI(s2, l2, u2)) =>
//        val s = bitVec_gcd(s1, s2)
//        val l = if (smt_bvule(l1, l2) == TrueLiteral) l1 else lowestPossibleValue
//        val u = if (smt_bvuge(u1, u2) == TrueLiteral) u1 else smt_bvsmod(smt_bvadd(highestPossibleValue, smt_bvsub(l1, BitVecLiteral(1, 64))), s)
//        SI(s, l, u)
//    }
//  }
//
//  /**
//   * Calculating strided interval for a list of values using accumulative gcd.
//   *
//   * @param x the list of values
//   * @return the strided interval representing the values in the list
//   */
//  def valuesToSI(x: List[BitVecLiteral]): StridedInterval[BitVecLiteral] = {
//    if (x.isEmpty) {
//      SIBottom
//    } else {
//      val l = bitVec_min(x)
//      val u = bitVec_max(x)
//      val initialStride = smt_bvsub(u, l)
//      val stride = x.foldLeft(initialStride) {
//        case (acc, v) => bitVec_gcd(smt_bvsub(v, l), acc)
//      }
//      SI(stride, l, u)
//    }
//  }
}

trait ValueSet[+T]

case class VS[T](m: Map[T, StridedWrappedInterval]) extends ValueSet[T] {
  override def toString: String = m.toString
}

case object VSBottom extends ValueSet[Nothing] {
  override def toString = "VSBot"
}

case object VSTop extends ValueSet[Nothing] {
  override def toString = "VSTop"
}

/** The lattice of integers with the standard ordering.
 */
class ValueSetLattice[T] extends Lattice[ValueSet[T]] {

  override val bottom: ValueSet[T] = VSBottom
  override def top: ValueSet[T] = VSTop

  val lattice: SASILattice = SASILattice()

  override def lub(x: ValueSet[T], y: ValueSet[T]): ValueSet[T] = {
    (x, y) match {
      case (VSBottom, t) => t
      case (t, VSBottom) => t
      case (VSTop, _) => VSTop
      case (_, VSTop) => VSTop
      case (VS(m1), VS(m2)) =>
        VS(m1.keys.foldLeft(m2) {
          case (acc, k) =>
            val v1 = m1(k)
            val v2 = m2(k)
            acc + (k -> lattice.lub(v1, v2))
        })
    }
  }

//  def meet(x: ValueSet[String], y: ValueSet[String]): ValueSet[String] = {
//    (x, y) match {
//      case (VSBottom, t) => VSBottom
//      case (t, VSBottom) => VSBottom
//      case (VSTop, _) => y
//      case (_, VSTop) => x
//      case (VS(m1), VS(m2)) =>
//        VS(m1.keys.foldLeft(m2) {
//          case (acc, k) =>
//            val v1 = m1(k)
//            val v2 = m2(k)
//            acc + (k -> lattice.meet(v1, v2))
//        })
//    }
//  }

  def add(x: ValueSet[T], y: ValueSet[T]): ValueSet[T] = {
    (x, y) match {
      case (VSBottom, t) => t
      case (t, VSBottom) => t
      case (VSTop, _) => VSTop
      case (_, VSTop) => VSTop
      case (VS(m1), VS(m2)) =>
        VS(m1.keys.foldLeft(m2) {
          case (acc, k) =>
            val v1 = m1(k)
            val v2 = m2(k)
            acc + (k -> lattice.add(v1, v2))
        })
    }
  }

  def add(x: ValueSet[T], y: BitVecLiteral): ValueSet[T] = {
    x match {
      case VSBottom => VSBottom
      case VSTop => VSTop
      case VS(m) =>
        VS(m.map {
          case (k, s) => k -> lattice.add(s, y.value, y.size) // TODO: is the size correct here?
        })
    }
  }

  def widen(vs1: ValueSet[T], vs2: ValueSet[T]): ValueSet[T] = {
    (vs1, vs2) match {
      case (VSBottom, t) => ???
      case (t, VSBottom) => ???
      case (VSTop, _) => VSTop
      case (_, VSTop) => VSTop
      case (VS(m1), VS(m2)) =>
        VS(m1.keys.foldLeft(m2) {
          case (acc, k) =>
            val v1 = m1(k)
            val v2 = m2(k)
            acc + (k -> lattice.widen(v1, v2))
        })
    }
  }

  def removeLowerBounds(vs: ValueSet[T]): ValueSet[T] = {
    vs match {
      case VSBottom => VSBottom
      case VSTop => VSTop
      case VS(m) =>
        VS(m.map {
          case (k, SI(s, l, u, w)) => k -> SI(s, lattice.lowestPossibleValue, u, w)
        })
    }
  }

  def removeUpperBound(vs: ValueSet[T]): ValueSet[T] = {
    vs match {
      case VSBottom => VSBottom
      case VSTop => VSTop
      case VS(m) =>
        VS(m.map {
          case (k, SI(s, l, u, w)) => k -> SI(s, l, lattice.highestPossibleValue, w)
        })
    }
  }

  /**
   * ∗(vs, s): Returns a pair of sets (F, P). F represents the set of “fully accessed” a-locs: it
   * consists of the a-locs that are of size s and whose starting addresses are in vs. P represents
   * the set of “partially accessed” a-locs: it consists of (i) a-locs whose starting addresses are in
   * vs but are not of size s, and (ii) a-locs whose addresses are in vs but whose starting addresses
   * and sizes do not meet the conditions to be in F. [Reference VSA paper]
   *
   * @param vsR2
   * @param s size of the dereference
   * @return
   */
  def dereference(s: BigInt, vs: ValueSet[String], mmm: MemoryModelMap): (Set[MemoryRegion], Set[MemoryRegion]) = {
    vs match {
      case VSBottom => VSBottom
      case VSTop => ??? //TODO: should this return everything?
      case VS(m) =>
        for (elem <- m) {
          if (elem._2 != lattice.bottom) { // region SI defined
            elem._2 match {
                case SI(stride, lower, upper) =>
                  val gamma: Set[BitVecLiteral] = lattice.gamma(SI(stride, lower, upper))
                  // TODO: Global memory size can be retrieved from the symbol table and are of size s
                  // Map addresses to exact memory locations
                  val fullyAccessedLocations = gamma.toList.flatMap(address => mmm.findStackFullAccessesOnly(address.value, s))

                    // Identify partially accessed locations (if any)
                  val partiallyAccessedLocations = gamma.toList.flatMap(address => mmm.findStackPartialAccessesOnly(address.value, s))

                    // Return the set of fully accessed locations and the set of partially accessed locations
                  return (fullyAccessedLocations.diff(partiallyAccessedLocations).asInstanceOf[Set[MemoryRegion]], partiallyAccessedLocations.asInstanceOf[Set[MemoryRegion]])
                case _ => ???
            }
          }
        }
    }
    (Set.empty, Set.empty)
  }
}



/** The powerset lattice of a set of elements of type `A` with subset ordering.
  */
class PowersetLattice[A] extends Lattice[Set[A]] {
  val bottom: Set[A] = Set.empty
  def lub(x: Set[A], y: Set[A]): Set[A] = x.union(y)
}

// Single element lattice (using Option)
class SingleElementLattice[T] extends Lattice[Option[T]] {
  val bottom: Option[T] = None
  def lub(x: Option[T], y: Option[T]): Option[T] = (x, y) match {
    case (None, None) => None
    case _ => Some(x.getOrElse(y.get))
  }
}

trait LiftedElement[+T]
case class Lift[T](el: T) extends LiftedElement[T] {
  override def toString = s"Lift($el)"
}
case object LiftedBottom extends LiftedElement[Nothing] {
  override def toString = "LiftBot"
}
/**
 * The lift lattice for `sublattice`.
 * Supports implicit lifting and unlifting.
 */
class LiftLattice[T, +L <: Lattice[T]](val sublattice: L) extends Lattice[LiftedElement[T]] {

  val bottom: LiftedElement[T] = LiftedBottom

  def lub(x: LiftedElement[T], y: LiftedElement[T]): LiftedElement[T] =
    (x, y) match {
      case (LiftedBottom, t) => t
      case (t, LiftedBottom) => t
      case (Lift(a), Lift(b)) => Lift(sublattice.lub(a, b))
    }

  /**
   * Lift elements of the sublattice to this lattice.
   * Note that this method is declared as implicit, so the conversion can be done automatically.
   */
  def lift(x: T): LiftedElement[T] = Lift(x)

  /**
   * Un-lift elements of this lattice to the sublattice.
   * Throws an IllegalArgumentException if trying to unlift the bottom element
   * Note that this method is declared as implicit, so the conversion can be done automatically.
   */
  def unlift(x: LiftedElement[T]): T = x match {
    case Lift(s) => s
    case LiftedBottom => throw new IllegalArgumentException("Cannot unlift bottom")
  }
}

trait TwoElement

case object TwoElementTop extends TwoElement
case object TwoElementBottom extends TwoElement


/**
 * A lattice with only top and bottom
 */
class TwoElementLattice extends Lattice[TwoElement]:
  override val bottom: TwoElement = TwoElementBottom
  override val top: TwoElement = TwoElementTop

  def lub(x: TwoElement, y: TwoElement): TwoElement = (x, y) match {
    case (TwoElementBottom, TwoElementBottom) => TwoElementBottom
    case _ => TwoElementTop
  }

trait FlatElement[+T]
case class FlatEl[T](el: T) extends FlatElement[T]
case object Top extends FlatElement[Nothing]
case object Bottom extends FlatElement[Nothing]

/** The flat lattice made of element of `X`. Top is greater than every other element, and Bottom is less than every
  * other element. No additional ordering is defined.
  */
class FlatLattice[X] extends Lattice[FlatElement[X]] {

  val bottom: FlatElement[X] = Bottom

  override val top: FlatElement[X] = Top

  def lub(x: FlatElement[X], y: FlatElement[X]): FlatElement[X] = (x, y) match {
    case (a, Bottom) => a
    case (Bottom, b) => b
    case (a, b) if a == b => a
    case (Top, _) => Top
    case (_, Top) => Top
    case _ => Top
  }
}

class TupleLattice[L1 <: Lattice[T1], L2 <: Lattice[T2], T1, T2](val lattice1: L1, val lattice2: L2) extends Lattice[(T1, T2)] {
  override val bottom: (T1, T2) = (lattice1.bottom, lattice2.bottom)

  override def lub(x: (T1, T2), y: (T1, T2)): (T1, T2) = {
    val (x1, x2) = x
    val (y1, y2) = y
    (lattice1.lub(x1, y1), lattice2.lub(x2, y2))
  }

  override def leq(x: (T1, T2), y: (T1, T2)): Boolean = {
    val (x1, x2) = x
    val (y1, y2) = y
    lattice1.leq(x1, y1) && lattice2.leq(x2, y2)
  }

  override def top: (T1, T2) = (lattice1.top, lattice2.top)
}

//trait StridedIntervalLattice[T] extends Lattice[(T, T, T)] {
//  override val bottom: (T, T, T) = (???, ???, ???)
//
//  override def lub(x: (T1, T2), y: (T1, T2)): (T1, T2) = {
//    val (x1, x2) = x
//    val (y1, y2) = y
//    (lattice1.lub(x1, y1), lattice2.lub(x2, y2))
//  }
//
//  override def leq(x: (T1, T2), y: (T1, T2)): Boolean = {
//    val (x1, x2) = x
//    val (y1, y2) = y
//    lattice1.leq(x1, y1) && lattice2.leq(x2, y2)
//  }
//
//  override def top: (T1, T2) = (lattice1.top, lattice2.top)
//}

/** A lattice of maps from a set of elements of type `A` to a lattice with element `L'. Bottom is the default value.
  */
class MapLattice[A, T, +L <: Lattice[T]](val sublattice: L) extends Lattice[Map[A, T]] {
  val bottom: Map[A, T] = Map().withDefaultValue(sublattice.bottom)
  def lub(x: Map[A, T], y: Map[A, T]): Map[A, T] =
    x.keys.foldLeft(y)((m, a) => m + (a -> sublattice.lub(x(a), y(a)))).withDefaultValue(sublattice.bottom)
}

/** Constant propagation lattice.
  *
  */
class ConstantPropagationLattice extends FlatLattice[BitVecLiteral] {
  private def apply(op: (BitVecLiteral, BitVecLiteral) => BitVecLiteral, a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = try {
    (a, b) match
      case (FlatEl(x), FlatEl(y)) => FlatEl(op(x, y))
      case (Bottom, _) => Bottom
      case (_, Bottom) => Bottom
      case (_, Top) => Top
      case (Top, _) => Top
  } catch {
    case e: Exception =>
      Logger.error(s"Failed on op $op with $a and $b")
      throw e
  }

  private def apply(op: BitVecLiteral => BitVecLiteral, a: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = a match
    case FlatEl(x) => FlatEl(op(x))
    case Top => Top
    case Bottom => Bottom

  def bv(a: BitVecLiteral): FlatElement[BitVecLiteral] = FlatEl(a)
  def bvadd(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvadd, a, b)
  def bvsub(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvsub, a, b)
  def bvmul(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvmul, a, b)
  def bvudiv(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvudiv, a, b)
  def bvsdiv(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvsdiv, a, b)
  def bvsrem(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvsrem, a, b)
  def bvurem(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvurem, a, b)
  def bvsmod(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvsmod, a, b)
  def bvand(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvand, a, b)
  def bvor(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvor, a, b)
  def bvxor(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvxor, a, b)
  def bvnand(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvnand, a, b)
  def bvnor(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvnor, a, b)
  def bvxnor(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvxnor, a, b)
  def bvnot(a: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvnot, a)
  def bvneg(a: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvneg, a)
  def bvshl(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvshl, a, b)
  def bvlshr(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvlshr, a, b)
  def bvashr(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvashr, a, b)
  def bvcomp(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_bvcomp, a, b)
  def zero_extend(width: Int, a: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_zero_extend(width, _: BitVecLiteral), a)
  def sign_extend(width: Int, a: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_sign_extend(width, _: BitVecLiteral), a)
  def extract(high: Int, low: Int, a: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] =
    apply(BitVectorEval.boogie_extract(high, low, _: BitVecLiteral), a)
  def concat(a: FlatElement[BitVecLiteral], b: FlatElement[BitVecLiteral]): FlatElement[BitVecLiteral] = apply(BitVectorEval.smt_concat, a, b)
}

/** Constant propagation lattice.
 *
 */
class ConstantPropagationLatticeWithSSA extends PowersetLattice[BitVecLiteral] {
  private def apply(op: (BitVecLiteral, BitVecLiteral) => BitVecLiteral, a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] =
    val res = for {
      x <- a
      y <- b
    } yield op(x, y)
    res

  private def apply(op: BitVecLiteral => BitVecLiteral, a: Set[BitVecLiteral]): Set[BitVecLiteral] =
    val res = for {
      x <- a
    } yield op(x)
    res

  def bv(a: BitVecLiteral): Set[BitVecLiteral] = Set(a)
  def bvadd(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvadd, a, b)
  def bvsub(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvsub, a, b)
  def bvmul(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvmul, a, b)
  def bvudiv(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvudiv, a, b)
  def bvsdiv(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvsdiv, a, b)
  def bvsrem(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvsrem, a, b)
  def bvurem(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvurem, a, b)
  def bvsmod(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvsmod, a, b)
  def bvand(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvand, a, b)
  def bvor(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvor, a, b)
  def bvxor(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvxor, a, b)
  def bvnand(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvnand, a, b)
  def bvnor(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvnor, a, b)
  def bvxnor(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvxnor, a, b)
  def bvnot(a: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvnot, a)
  def bvneg(a: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvneg, a)
  def bvshl(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvshl, a, b)
  def bvlshr(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvlshr, a, b)
  def bvashr(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvashr, a, b)
  def bvcomp(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_bvcomp, a, b)
  def zero_extend(width: Int, a: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_zero_extend(width, _: BitVecLiteral), a)
  def sign_extend(width: Int, a: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_sign_extend(width, _: BitVecLiteral), a)

  def extract(high: Int, low: Int, a: Set[BitVecLiteral]): Set[BitVecLiteral] =
    apply(BitVectorEval.boogie_extract(high, low, _: BitVecLiteral), a)

  def concat(a: Set[BitVecLiteral], b: Set[BitVecLiteral]): Set[BitVecLiteral] = apply(BitVectorEval.smt_concat, a, b)
}