package ir.dsl

import util.intersperse
import util.twine.Twine

import scala.compiletime.{constValue, erasedValue, error, summonInline}
import scala.deriving.Mirror

/**
 * ToScala deriving
 * ================
 *
 * This file implements the automatic derivation of ToScala instances for product and sum types.
 *
 * It can be used in these ways:
 *
 *     // to derive for instances of a sealed trait
 *     sealed trait Trait derives ToScala
 *
 *     // to manually derive for a given type (the above syntax desugars to this)
 *     given ToScala[TheType] = ToScala.derived
 *
 *     // to override the ToScala implementation for particular cases
 *     enum EAAA {
 *       case A
 *       case B
 *     }
 *     given ToScala[EAAA] with
 *       ToScala.deriveWithExclusions[EAAA, EAAA.A.type](
 *         (x: EAAA.A.type) => s"custom implementation for EAAA.A")
 */

/**
 * NOTE: The version of Scala we use is the 3.3.x LTS and it predates a syntax change
 * for given declarations. In 3.6, the `given` syntax was changed to use `=`
 * instead of `with`. We must use the `with` syntax, otherwise a syntax error will be
 * reported. Be aware that online documentation might use the newer syntax.
 *
 * See: https://docs.scala-lang.org/scala3/reference/contextual/previous-givens.html
 */

/**
 * Mirrors
 * -------
 *
 * Scala 3 provides a number of options for [meta-programming], each with different
 * levels of abstraction and power. Here, the task is very straightforward so we use the
 * high-level abstractions of inline functions and [Mirrors].
 *
 * [meta-programming]: https://docs.scala-lang.org/scala3/reference/metaprogramming/index.html
 * [Mirrors]: https://docs.scala-lang.org/scala3/reference/contextual/derivation.html#mirror-1
 *
 * An inline function is one which is inlined at its call-sites. When combined with
 * inline match statements, this allows us to write code which is executed at compile-time
 * and type-checked within the context of its call-site. This is important for summoning
 * existing given instances and resolving constant types.
 *
 * Given a sum / product type T, its mirror type `Mirror.Of[T]` provides compile-time
 * information about its cases / fields (respectively). Each Mirror is an instance of
 * either Mirror.Sum or Mirror.Product, with Mirror.Product having the additional
 * subtype Mirror.Singleton. See [Mirrors].
 *
 *     sealed trait Mirror {
 *
 *       /** the type being mirrored */
 *       type MirroredType
 *
 *       /** the type of the elements of the mirrored type */
 *       type MirroredElemTypes
 *
 *       /** The mirrored *-type */
 *       type MirroredMonoType
 *
 *       /** The name of the type */
 *       type MirroredLabel <: String
 *
 *       /** The names of the elements of the type */
 *       type MirroredElemLabels <: Tuple
 *     }
 *
 *     object Mirror {
 *       trait Product extends Mirror { ... }
 *       trait Sum extends Mirror { ... }
 *
 *       trait Singleton extends Product { ... }
 *     }
 *
 * A mirror instance is generated by the compiler for any supported type. It can be
 * obtained using the "given" system, e.g., using "summon[]" or "using". For example:
 *
 *     import scala.deriving.*
 *
 *     enum AB {
 *       case A
 *       case B
 *     }
 *
 *     // obtaining a mirror with summon
 *     val mirror = summon[Mirror.Of[AB]]
 *
 *     // obtaining a mirror with a "using" parameter
 *     def getMirror[T](using m: Mirror.Of[T]) = m
 *
 *     println(getMirror[AB]) // -> AB$@4bc28c33
 *
 * The information within a Mirror, being compile-time, is provided as *type* members.
 * These types are literal types (e.g., `val x : "s" = "s"`) and tuples of literal types
 * (e.g., `val t: ("a", 2) = ("a", 2)`). These types can be manipulated using
 * [compile-time operations] and inline statements.
 *
 * For example, to extract a string value from the literal string type we can use
 * `constValue`:
 *
 *     import scala.compiletime.*
 *
 *     inline def getLabel[T](using m: Mirror.Of[T]): String =
 *       constValue[m.MirroredLabel]
 *
 *     println(getLabel[AB]) // -> AB
 *
 * The use of `inline` is important here; constValue can only be used on types which are
 * known to be compile-time literals. An ordinary function with generic type
 * parameters cannot guarantee those types will be literal types (there is no way of
 * specifying `def f[T <: Literal] = ...`). Using `inline` will inline the function
 * body at its call-site, allowing the literal type to be propagated directly.
 *
 * [compile-time operations]: https://docs.scala-lang.org/scala3/reference/metaprogramming/compiletime-ops.html
 *
 * An important compile-time function is `erasedValue[]`. This will manifest an
 * unspecified term of a particular type. This term is only usable at compile-time;
 * it is a compile error if a term from erasedValue is emitted to runtime.
 * Crucially, this enables pattern matching based on the structure of a type.
 *
 * For example, this function recurses over a tuple type to obtain a list of its values
 * (this is useful because `constValue` does not work on tuples).
 * Note that the return type is `List[?]`, representing a list of unknown contents.
 * This is necessary because the types of its elements, contained within `ElemLabels`, cannot
 * be extracted into the type signature.
 *
 *     inline def constValueOfTuple[ElemLabels <: Tuple]: List[?] =
 *       inline erasedValue[ElemLabels] match
 *         case _: (t *: rest) => constValue[t] :: constValueOfTuple[rest]
 *         case _: EmptyTuple => Nil
 *
 *     println(elemLabels[("a", "b", "c", 2, 3.0)])
 *     // -> List(a, b, c, 2, 3.0)
 *
 *     // we can also use this with the MirroredElemLabels type
 *     val mirror = summon[Mirror.Of[AB]]
 *     println(elemLabels[mirror.MirroredElemLabels])
 *    // -> List(A, B)
 *
 * These constructs are the basis of the code in this file. We also use the compile-time
 * function `summonInline[]`. Like `summon`, this summons a given value of the specified type.
 * However, when used within an inline method, the summoning is deferred until
 * after the code is inlined. This allows the summon to obtain instances in-scope at
 * the call-site but not the definition-site.
 */

/**
 * Deriving instances
 * ------------------
 *
 * The automatic derivation API is very simple. For a trait Trait[T],
 * a function called "derived" in its companion object will be invoked to
 * generate instances of Trait[T].
 *
 * For example:
 *
 *     trait HasMagic[T]:
 *       extension (x: T)
 *         def magic: Int
 *
 *     object HasMagic {
 *       def derived[T]: HasMagic[T] = new HasMagic[T] {
 *         extension (x: T)
 *           def magic: Int = 123
 *       }
 *     }
 *
 *     enum AB derives HasMagic {
 *       case A
 *       case B
 *     }
 *
 *     println(AB.A.magic) // -> 123
 *
 * The syntax "derives HasMagic" is nothing more than syntax sugar for:
 *
 *     given HasMagic[AB] = HasMagic.derived
 *
 * By adding a `using Mirror.Of[T]` parameter to the `derived` function and
 * marking it as inline, we can connect this to our code that uses Mirrors and generate
 * the type-class instances we need.
 *
 */

object ToScalaDeriving {

  /**
   * Support functions
   * -----------------
   *
   * The following functions are used to recursively obtain type-class instances
   * for the tuple of types in MirroredElemTypes.
   *
   * Aside from summonOrCustom, these are largely copied from:
   * https://docs.scala-lang.org/scala3/reference/contextual/derivation.html#how-to-write-a-type-class-derived-method-using-low-level-mechanisms-1
   */

  /**
   * Summon ToScala instances for each type in the Elems tuple of types. Also handles exclusions.
   */
  inline def summonInstances[T, Elems <: Tuple, Excl <: T](using
    m: Mirror.Of[T]
  )(custom: => ToScala[Excl]): List[ToScala[?]] =

    // NOTE: this is an unrolled recursion to avoid the "Maximal number of successive inlines (32) exceeded" error
    inline erasedValue[Elems] match
      case _: (t1 *: t2 *: t3 *: t4 *: rest) =>
        summonOrCustom[T, t1, Excl](custom) // first field / case
          :: summonOrCustom[T, t2, Excl](custom) // second field / case
          :: summonOrCustom[T, t3, Excl](custom) // third field / case
          :: summonOrCustom[T, t4, Excl](custom) // fourth field / case
          :: summonInstances[T, rest, Excl](custom) // + 4
      case _: (t1 *: t2 *: t3 *: EmptyTuple) =>
        summonOrCustom[T, t1, Excl](custom) // first field / case
          :: summonOrCustom[T, t2, Excl](custom) // second field / case
          :: summonOrCustom[T, t3, Excl](custom) // third field / case
          :: List()
      case _: (t1 *: t2 *: EmptyTuple) =>
        summonOrCustom[T, t1, Excl](custom) // first field / case
          :: summonOrCustom[T, t2, Excl](custom) // second field / case
          :: List()
      case _: (t *: EmptyTuple) =>
        summonOrCustom[T, t, Excl](custom) // first field / case
          :: List()
      case _: EmptyTuple => Nil

  /**
   * Summon ToScala for the given type or apply a custom exclusion.
   */
  inline def summonOrCustom[T, t, Excl <: T](using m: Mirror.Of[T])(custom: => ToScala[Excl]): ToScala[?] =
    inline erasedValue[t] match
      case _: Excl => custom
      case _ => deriveOrSummon[T, t, Excl](custom)

  /**
   * Obtain a ToScala for the given type, either by summoning an existing instance
   * or deriving a new instance.
   *
   * Detects infinite self-recursion.
   * Recursively derives subtypes (i.e. cases) of sum types.
   * Otherwise, summons an external ToScala instance for the given type.
   */
  inline def deriveOrSummon[T, Elem, Excl <: T](using m: Mirror.Of[T])(custom: => ToScala[Excl]): ToScala[Elem] =
    inline (erasedValue[Elem], erasedValue[T]) match
      // Elem <: T and T <: Elem means T == Elem
      case _: (T, Elem) =>
        error(
          "Infinite recursive derivation. The type " + constValue[m.MirroredLabel] + " appears in its own constructor."
        )

      // Elem <: T means the element is a subtype and we should recurse
      case _: (T, _) =>
        deriveWithExclusions[Elem, Elem & Excl](using summonInline[Mirror.Of[Elem]])(
          custom
        ) // recursively derive sum case

      // otherwise, including the case where the Elem is a supertype of T, we summon.
      case _ => summonInline[ToScala[Elem]] // summon externally-defined instance

  /**
   * Implementation for sums and products
   * ------------------------------------
   *
   * Every mirror represents either a sum or a product type (itself containing more
   * sum or product types). As such, we only need to implement derivation for these two cases.
   */

  /**
   * Implements ToScala for the given value of a sum type.
   *
   * This is done by obtaining ToScala instances for each case and invoking the appropriate
   * instance based on the value.
   */
  inline def toScalaOfSum[T](instances: => List[ToScala[?]], name: String, idx: Int, x: T): Twine =
    val prefix = inline x match
      case _: scala.reflect.Enum => name + "."
      case _ => ""

    Twine(prefix, instances(idx).asInstanceOf[ToScala[T]].toScalaLines(x))

  /**
   * Implements ToScala instance for the given value of a product type.
   *
   * This is done by obtaining ToScala instances for the fields, then joining their
   * results.
   */
  inline def toScalaOfProduct[T](
    instances: => List[ToScala[?]],
    name: String,
    inline isSingleton: Boolean,
    x: T
  ): Twine =

    val (open, close) = inline isSingleton match
      case true => ("", "")
      case false => ("(", ")")

    val args =
      val elems = x.asInstanceOf[Product].productIterator
      (instances.iterator zip elems)
        .map((f, x) => f.asInstanceOf[ToScala[Any]].toScalaLines(x))
        .toList

    if (args.exists(Twine.shallowIsMultiline)) {
      Twine.indentNested(name + open, args, close)
    } else {
      Twine(name + open, Twine(args.intersperse(", ")), close)
    }

  /**
   * Helper class for wrapping a lambda function into a ToScala instance,
   * given a lambda returning a Twine.
   */
  class Make[T](f: T => Twine) extends ToScalaLines[T] {
    extension (x: T) def toScalaLines: Twine = f(x)
  }

  /**
   * Helper class for wrapping a lambda function into a ToScala instance,
   * given a lambda returning a String.
   */
  class MakeString[T](f: T => String) extends ToScalaString[T] {
    extension (x: T) def toScala = f(x)
  }

  /**
   * Witnesses the logical principle of explosion.
   */
  def absurd[T](x: Nothing): T = x

  /**
   * Entry point for derivation. Used by Scala's "deriving ToScala" syntax.
   */
  inline def derived[T](using m: Mirror.Of[T]): ToScala[T] =
    deriveWithExclusions(Make[Nothing](absurd)) // derive with defaults (no exclusions)

  /**
   * Alternative entry point for deriving ToScala. Allows for specifying
   * a custom implementation for a certain subset of cases.
   */
  inline def deriveWithExclusions[T, Excl <: T](using m: Mirror.Of[T])(custom: => ToScala[Excl]): ToScala[T] = {

    lazy val elemInstances = inline m match
      case _: Mirror.SumOf[T] =>
        summonInstances[T, m.MirroredElemTypes, Excl](custom) // obtain given instances for sum cases
      case _: Mirror.ProductOf[T] =>
        summonInstances[T, m.MirroredElemTypes, Excl](custom) // obtain given instances for product fields

    inline val isSingleton = inline m match
      case _: Mirror.Singleton | _: Mirror.SingletonProxy => true
      case _ => false

    inline val name = constValue[m.MirroredLabel]
    Make[T]((x: T) =>
      inline m match
        case s: Mirror.SumOf[T] => toScalaOfSum[T](elemInstances, name, s.ordinal(x), x)
        case p: Mirror.ProductOf[T] => toScalaOfProduct[T](elemInstances, name, isSingleton, x)
    )
  }

}
