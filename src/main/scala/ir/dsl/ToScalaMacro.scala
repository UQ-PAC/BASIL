package ir.dsl

import scala.deriving.{Mirror}
import scala.compiletime.{summonInline, erasedValue, constValue, error}

/**
 * ToScala deriving
 * ================
 *
 * This file implements the automatic derivation of ToScala instances for product and sum types.
 *
 * It can be used in these ways:
 *
 *     // to derive for instances of a sealed trait
 *     sealed trait Trait derives Boop
 *
 *     // to manually derive for a given type (the above syntax desugars to this)
 *     given Boop[TheType] = Boop.derived
 *
 *     // to override the ToScala implementation for particular cases
 *     enum EAAA {
 *       case A
 *       case B
 *     }
 *     given Boop[EAAA] =
 *       Boop.deriveWithExclusions[EAAA, EAAA.A.type](
 *         (x: EAAA.A.type) => s"custom implementation for EAAA.A")
 */

/**
 * Mirrors
 * -------
 *
 * Scala 3 provides a number of options for [meta-programming], each with different
 * levels of abstraction and power. Here, the task is very straightforward so we use the
 * high-level abstractions of inline functions and [Mirrors].
 *
 * [meta-programming]: https://docs.scala-lang.org/scala3/reference/metaprogramming/index.html
 * [Mirrors]: https://docs.scala-lang.org/scala3/reference/contextual/derivation.html#mirror-1
 *
 * An inline function is one which is inlined at its call-sites. When combined with
 * inline match statements, this allows us to write code which is executed at compile-time
 * and type-checked within the context of its call-site. This is important for summoning
 * existing given instances and resolving constant types.
 *
 * Given a sum / product type T, its mirror type `Mirror.Of[T]` provides compile-time
 * information about its cases / fields (respectively). Each Mirror is an instance of
 * either Mirror.Sum or Mirror.Product, with Mirror.Product having the additional
 * subtype Mirror.Singleton. See [Mirrors].
 *
 *     sealed trait Mirror {
 *
 *       /** the type being mirrored */
 *       type MirroredType
 *
 *       /** the type of the elements of the mirrored type */
 *       type MirroredElemTypes
 *
 *       /** The mirrored *-type */
 *       type MirroredMonoType
 *
 *       /** The name of the type */
 *       type MirroredLabel <: String
 *
 *       /** The names of the elements of the type */
 *       type MirroredElemLabels <: Tuple
 *     }
 *
 *     object Mirror {
 *       trait Product extends Mirror { ... }
 *       trait Sum extends Mirror { ... }
 *
 *       trait Singleton extends Product { ... }
 *     }
 *
 * A mirror instance is generated by the compiler for any supported type. It can be
 * obtained using the "given" system, e.g., using "summon[]" or "using". For example:
 *
 *     import scala.deriving.*
 *
 *     enum AB {
 *       case A
 *       case B
 *     }
 *
 *     // obtaining a mirror with summon
 *     val mirror = summon[Mirror.Of[AB]]
 *
 *     // obtaining a mirror with a "using" parameter
 *     def getMirror[T](using m: Mirror.Of[T]) = m
 *
 *     println(getMirror[AB]) // -> AB$@4bc28c33
 *
 * The information within a Mirror, being compile-time, is provided as *type* members.
 * These types are literal types (e.g., `val x : "s" = "s"`) and tuples of literal types
 * (e.g., `val t: ("a", 2) = ("a", 2)`). These types can be manipulated using
 * [compile-time operations] and inline statements.
 *
 * For example, to extract a string value from the literal string type we can use
 * `constValue`:
 *
 *     import scala.compiletime.*
 *
 *     inline def getLabel[T](using m: Mirror.Of[T]): String =
 *       constValue[m.MirroredLabel]
 *
 *     println(getLabel[AB]) // -> AB
 *
 * The use of `inline` is important here; constValue can only be used on types which are
 * known to be compile-time literals. An ordinary function with generic type
 * parameters cannot guarantee those types will be literal types (there is no way of
 * specifying `def f[T <: Literal] = ...`). Using `inline` will inline the function
 * body at its call-site, allowing the literal type to be propagated directly.
 *
 * [compile-time operations]: https://docs.scala-lang.org/scala3/reference/metaprogramming/compiletime-ops.html
 *
 * An important compile-time function is `erasedValue[]`. This will manifest an
 * unspecified term of a particular type. This term is only usable at compile-time;
 * it is a compile error if a term from erasedValue is emitted to runtime.
 * Crucially, this enables pattern matching based on the structure of a type.
 *
 * For example, this function recurses over a tuple type to obtain a list of its values
 * (this is useful because `constValue` does not work on tuples).
 * Note that the return type is `List[?]`, representing a list of unknown contents.
 * This is necessary because the types of its elements, contained within `ElemLabels`, cannot
 * be extracted into the type signature.
 *
 *     inline def constValueOfTuple[ElemLabels <: Tuple]: List[?] =
 *       inline erasedValue[ElemLabels] match
 *         case _: (t *: rest) => constValue[t] :: constValueOfTuple[rest]
 *         case _: EmptyTuple => Nil
 *
 *     println(elemLabels[("a", "b", "c", 2, 3.0)])
 *     // -> List(a, b, c, 2, 3.0)
 *
 *     // we can also use this with the MirroredElemLabels type
 *     val mirror = summon[Mirror.Of[AB]]
 *     println(elemLabels[mirror.MirroredElemLabels])
 *    // -> List(A, B)
 *
 * These constructs are the basis of the code in this file. We also use the compile-time
 * function `summonInline[]`. Like `summon`, this summons a given value of the specified type.
 * However, when used within an inline method, the summoning is deferred until
 * after the code is inlined. This allows the summon to obtain instances in-scope at
 * the call-site but not the definition-site.
 */

/**
 * Deriving instances
 * ------------------
 *
 * The automatic derivation API is very simple. For a trait Trait[T],
 * a function called "derived" in its companion object will be invoked to
 * generate instances of Trait[T].
 *
 * For example:
 *
 *     trait HasMagic[T]:
 *       extension (x: T)
 *         def magic: Int
 *
 *     object HasMagic {
 *       def derived[T]: HasMagic[T] = new HasMagic[T] {
 *         extension (x: T)
 *           def magic: Int = 123
 *       }
 *     }
 *
 *     enum AB derives HasMagic {
 *       case A
 *       case B
 *     }
 *
 *     println(AB.A.magic) // -> 123
 *
 * The syntax "derives HasMagic" is nothing more than syntax sugar for:
 *
 *     given HasMagic[AB] = HasMagic.derived
 *
 * By adding a `using Mirror.Of[T]` parameter to the `derived` function and
 * marking it as inline, we can connect this to our code that uses Mirrors and generate
 * the type-class instances we need.
 *
 */


/**
 * Support functions
 * -----------------
 *
 * The following functions are used to recursively obtain type-class instances
 * for the tuple of types in MirroredElemTypes.
 *
 * Aside from summonOrCustom, these are largely copied from:
 * https://docs.scala-lang.org/scala3/reference/contextual/derivation.html#how-to-write-a-type-class-derived-method-using-low-level-mechanisms-1
 */

/**
 * Summon Boop instances for each type in the Elems tuple of types. Also handles exclusions.
 */
inline def summonInstances[T, Elems <: Tuple, Excl <: T](using m: Mirror.Of[T]): List[Boop[?]] =

  // NOTE: this is an unrolled recursion to avoid the "Maximal number of successive inlines (32) exceeded" error
  inline erasedValue[Elems] match
    case _: (t1 *: t2 *: t3 *: t4 *: rest) =>
      summonOrCustom[T, t1, Excl] // first field / case
      :: summonOrCustom[T, t2, Excl] // second field / case
      :: summonOrCustom[T, t3, Excl] // third field / case
      :: summonOrCustom[T, t4, Excl] // fourth field / case
      :: summonInstances[T, rest, Excl] // + 4
    case _: (t1 *: t2 *: t3 *: EmptyTuple) =>
      summonOrCustom[T, t1, Excl] // first field / case
      :: summonOrCustom[T, t2, Excl] // second field / case
      :: summonOrCustom[T, t3, Excl] // third field / case
      :: List()
    case _: (t1 *: t2 *: EmptyTuple) =>
      summonOrCustom[T, t1, Excl] // first field / case
      :: summonOrCustom[T, t2, Excl] // second field / case
      :: List()
    case _: (t *: EmptyTuple) =>
      summonOrCustom[T, t, Excl] // first field / case
      :: List()
    case _: EmptyTuple => Nil

/**
 * Summon Boop for the given type or apply a custom exclusion.
 */
inline def summonOrCustom[T, t, Excl](using m: Mirror.Of[T]): Boop[?] =
  inline erasedValue[t] match
    case _: Excl => summonInline[Boop.BoopImpl[Excl]]
    case _ => deriveOrSummon[T, t, Excl]

/**
 * Obtain a Boop for the given type, either by summoning an existing instance
 * or deriving a new instance.
 *
 * Detects infinite self-recursion.
 * Recursively derives subtypes (i.e. cases) of sum types.
 * Otherwise, summons an external Boop instance for the given type.
 */
inline def deriveOrSummon[T, Elem, Excl](using m: Mirror.Of[T]): Boop[Elem] =
  inline (erasedValue[Elem], erasedValue[T]) match
    // Elem <: T and T <: Elem means T == Elem
    case _: (T, Elem) => error("Infinite recursive derivation. The type " + constValue[m.MirroredLabel] + " appears in its own constructor.")

    // Elem <: T means the element is a subtype and we should recurse
    case _: (T, _) =>
      Boop.deriveWithExclusions(using summonInline[Mirror.Of[Elem]])(summonInline[Boop.BoopImpl[Excl]].boop) // recursively derive sum case

    // otherwise, including the case where the Elem is a supertype of T, we summon.
    case _ => summonInline[Boop[Elem]] // summon externally-defined instance


/**
 * Implementation for sums and products
 * ------------------------------------
 *
 * Every mirror represents either a sum or a product type (itself containing more
 * sum or product types). As such, we only need to implement derivation for these two cases.
 */

/**
 * Implements Boop for the given value of a sum type.
 *
 * This is done by obtaining Boop instances for each case and invoking the appropriate
 * instance based on the value.
 */
inline def boopOfSum[T](m: Mirror.SumOf[T], instances: => List[Boop[?]], x: T): String =
  val idx = m.ordinal(x)

  val name = constValue[m.MirroredLabel]
  val prefix = inline erasedValue[m.MirroredMonoType] match
    case _: scala.reflect.Enum => name + "."
    case _ => ""

  prefix + instances(idx).asInstanceOf[Boop[T]].boop(x)

/**
 * Implements Boop instance for the given value of a product type.
 *
 * This is done by obtaining Boop instances for the fields, then joining their
 * results.
 */
inline def boopOfProduct[T](m: Mirror.ProductOf[T], instances: => List[Boop[?]], x: T): String =
  val name = constValue[m.MirroredLabel]
  val args = inline m match
    case _: Mirror.Singleton => ""
    case _ =>
      val elems = x.asInstanceOf[Product].productIterator
      val args = (instances zip elems).map((f, x) => f.asInstanceOf[Boop[Any]].boop(x))
      args.mkString("(", ", ", ")")

  name + args


trait Boop[-A]:
  extension (x: A) def boop: String

object Boop {

  /**
   * Helper class for wrapping a lambda function into a Boop instance.
   */
  class BoopImpl[T](f: T => String) extends Boop[T] {
    extension (x: T) def boop: String = f(x)
  }

  /**
   * Witnesses the logical principle of explosion.
   */
  def absurd[T](x: Nothing): T = x

  /**
   * Entry point for derivation. Used by Scala's "deriving Boop" syntax.
   */
  inline def derived[T](using m: Mirror.Of[T]): Boop[T] =
    deriveWithExclusions[T, Nothing](absurd) // derive with defaults (no exclusions)

  /**
   * Alternative entry point for deriving Boop. Allows for specifying
   * a custom implementation for a certain subset of cases.
   */
  inline def deriveWithExclusions[T, Excl <: T](using m: Mirror.Of[T])(custom: => Excl => String) =
    given Boop.BoopImpl[Excl] = BoopImpl(custom)
    lazy val elemInstances = inline m match
      case _: Mirror.SumOf[T] => summonInstances[T, m.MirroredElemTypes, Excl] // obtain given instances for sum cases
      case _: Mirror.ProductOf[T] => summonInstances[T, m.MirroredElemTypes, Excl] // obtain given instances for product fields

    BoopImpl((x: T) =>
      inline m match
        case s: Mirror.SumOf[T] => boopOfSum(s, elemInstances, x)
        case p: Mirror.ProductOf[T] => boopOfProduct[T](p, elemInstances, x)
    )
}

