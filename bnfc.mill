package build
import mill._
import mill.util.Jvm
import scalalib._

import $file.util.DownloadModule
import scala.util.{Try}

/**
 * Module to process a BNFC (https://bnfc.digitalgrammars.com/) grammar
 * through the `bnfc` generator and through Antlr to produce a Java
 * dependency.
 */
trait BNFCModule extends JavaModule with JFlexCupModule {
  def bnfcPackageName: String
  def bnfcSource: Task[PathRef]
  def bnfcExtraArgs: Seq[String] = Nil
  def antlrRuntime: Dep

  override def jflexSource = Task.Source {
    PathRef(bnfcGenerated().path / bnfcPackageName / "Yylex")
  }
  override def javaCupSource = Task.Source {
    PathRef(bnfcGenerated().path / bnfcPackageName / "_cup.cup")
  }

  object bnfcBinary extends DownloadModule {
    def version = "2.9.5"
    def name = s"bnfc-$version-${System.currentTimeMillis()}$suffix"
    def url = s"https://github.com/BNFC/bnfc/releases/download/v$version/bnfc-$version$suffix"
    // https://github.com/BNFC/bnfc/releases

    def local = Task.Input {
      Try(os.proc("bnfc", "--version").call())
        .map(Function.const("bnfc"))
        .toEither
        .left.map(_.toString)
    }

    def osName = System.getProperty("os.name")

    def suffix = if (osName.contains("nux")) {
      "-linux.binary"
    } else if (osName.contains("Mac")) {
      "-mac.binary"
    } else if (osName.startsWith("Windows")) {
      ".exe"
    }
  }

  override def sources = Task.Sources {
    super.sources() ++ Seq(bnfcGenerated())
  }

  /**
    * Runs the BNFC binary.
    */
  override def run(args: Task[Args] = Task.Anon(Args())) = Task.Command {
    val res = os.call(bnfcBinary.path() +: args().value, stdout = os.Inherit, check = false)
    Task.ctx().systemExit(res.exitCode)
    ()
  }

  def bnfcGenerated = Task {
    val args = Seq("--java", "--jflex", bnfcSource().path.toString, "-m", "-o", Task.dest.toString, "-l")
    os.call(bnfcBinary.path() +: (args ++ bnfcExtraArgs))
    PathRef(Task.dest)
  }
}

trait JFlexCupModule extends JavaModule {
  def jflexSource: T[PathRef]
  def javaCupSource: T[PathRef]

  def jflexDep = ivy"de.jflex:jflex:1.9.1"
  def javaCupDep = ivy"com.github.vbmacher:java-cup:11b-20160615-3"
  def javaCupRuntimeDep = ivy"com.github.vbmacher:java-cup-runtime:11b-20160615-3"

  def ivyDeps = Task {
    super.ivyDeps() ++ Agg(javaCupRuntimeDep)
  }

  object jflex extends JavaModule {
    def compileIvyDeps = Agg(jflexDep)
    def generated = Task {
      Jvm.callProcess(
        mainClass = "jflex.Main",
        mainArgs = Seq(
          jflexSource().path.toString,
          "-d",
          Task.dest.toString
        ),
        classPath = compileClasspath().map(_.path).toList
      )
      PathRef(Task.dest)
    }
  }

  object cup extends JavaModule {
    def compileIvyDeps = Agg(javaCupDep)
    def generated = Task {
      Jvm.callProcess(
        mainClass = "java_cup.Main",
        mainArgs = Seq(
          "-locations", "-expect", "100",
          javaCupSource().path.toString
        ),
        cwd = Task.dest,
        classPath = compileClasspath().map(_.path).toList
      )
      PathRef(Task.dest)
    }
  }

  override def sources = Task.Sources {
    super.sources() ++ Seq(jflex.generated(), cup.generated())
  }
}
