package build
import $packages._

import mill._
import scalalib._
import coursier.core.Authentication
import coursier.maven.MavenRepository

import $file.basilmill.mdbook.mdbookBinary
import $file.basilmill.bnfc.BNFCJFlexModule
import $file.basilmill.antlr.AntlrModule
import $file.basilmill.basildocs.BasilDocs
import $file.basilmill.basilversion.BasilVersion
import $file.basilmill.profile.ProfileModule
import $file.basilmill.z3.Z3Module

import os.Path

import $ivy.`com.goyeau::mill-scalafix::0.4.2`
import $ivy.`com.lihaoyi::mill-contrib-scalapblib:$MILL_VERSION`
import contrib.scalapblib._
import com.goyeau.mill.scalafix.ScalafixModule

object `package` extends RootModule with ScalaModule with BasilDocs with BasilVersion with ScalafixModule {
  // ammoniteVersion should be updated whenever scalaVersion is changed. see, for example,
  // https://mvnrepository.com/artifact/com.lihaoyi/ammonite_3.4.3 to list valid versions.
  def scalaVersion = "3.3.4"

  val ammonite = "3.0.2"
  override def ammoniteVersion = ammonite

  def moduleDeps = Seq(basilAntlr, basilProto, bnfc)

  def scalacOptions: T[Seq[String]] = Seq("-deprecation", "-Wunused:imports", "-feature")

  val javaTests = ivy"com.novocode:junit-interface:0.11"
  val scalaTests = ivy"org.scalatest::scalatest:3.2.19"
  val scalaCheck = ivy"org.scalatestplus::scalacheck-1-18:3.2.19.0"
  val scalactic = ivy"org.scalactic::scalactic:3.2.19"
  val antlrRuntime = ivy"org.antlr:antlr4-runtime:4.9"
  val sourceCode = ivy"com.lihaoyi::sourcecode:0.4.2"
  val mainArgs = ivy"com.lihaoyi::mainargs:0.7.6"
  val scalapb = ivy"com.thesamet.scalapb::scalapb-runtime:0.11.15"
  val upickle = ivy"com.lihaoyi::upickle:4.2.1"
  val aslpOffline = ivy"io.github.uq-pac::lifter:0.1.0"
  val javaSmt = ivy"org.sosy-lab:java-smt:5.0.0"
  val javaSmtZ3 = ivy"org.sosy-lab:javasmt-solver-z3:4.14.0"

  override def ivyDeps = Agg(scalactic, sourceCode, mainArgs, upickle, aslpOffline, javaSmt, javaSmtZ3)

  override def repositoriesTask = Task.Anon {
    super.repositoriesTask() :+ MavenRepository(
      "https://maven.pkg.github.com/UQ-PAC/aslp",
      // this token will expire in one year. if downloading the lifter dependency fails,
      // re-generate a read:packages token.
      authentication = Some(Authentication("rina-bot1", "iH2Yg4xigOuRtBRoTrQWS85I26vgDuZ29Mgt_phg".reverse))
      // XXX: .reverse is used to subvert Github's secret detection, which will invalidate the
      // token if it sees it being committed....
    )
  }

  def mainClass = Some("Main")

  def millSourcePath = super.millSourcePath / "src"
  def sources = Task.Sources {
    Seq(PathRef(this.millSourcePath / "main" / "scala"))
  }

  def forkArgs = Task {
    super.forkArgs() :+ (s"-Djava.library.path=${z3.install()}")
  }

  override def scalafixConfig = Task {
    Some(Task.workspace / ".scalafix.conf")
  }

  object test extends ScalaTests with TestModule.ScalaTest with ScalafixModule {

    override def ammoniteVersion = ammonite
    def ivyDeps = Agg(scalaTests, scalaCheck, javaTests)
    def sources = Task.Sources {
      Seq(PathRef(this.millSourcePath / "scala"))
    }

    override def scalafixConfig = build.scalafixConfig

    def forkArgs = Task {
      val args = super.forkArgs() :+ (s"-Djava.library.path=\"${z3.install()}\"")
      println(args)
      args
    }

    // note: toBoolean accepts precisely "true" or "false"
    def basilTestParallel = Task.Input {
      Task.env.get("BASIL_TEST_PARALLEL").fold(false)(_.toBoolean)
    }

    def testForkGrouping = Task {
      val numGroups = 13
      if (basilTestParallel()) {
        discoveredTestClasses().zipWithIndex.groupMap(x => x._2 % numGroups)(_._1).values.toSeq
      } else {
        Seq(discoveredTestClasses())
      }
    }
  }

  /** Updates the expected
    */

  def updateExpectedBAP() = Task.Command {
    val correctPath = test.millSourcePath / "correct"
    val incorrectPath = test.millSourcePath / "incorrect"

    expectedUpdate(correctPath, true, true)
    expectedUpdate(incorrectPath, false, true)
  }

  def updateExpectedGTIRB() = Task.Command {
    val correctPath = test.millSourcePath / "correct"
    val incorrectPath = test.millSourcePath / "incorrect"

    expectedUpdate(correctPath, true, false)
    expectedUpdate(incorrectPath, false, false)
  }

  def updateExpectedExtraSpec() = Task.Command {
    val correctPath = test.millSourcePath / "extraspec_correct"
    val incorrectPath = test.millSourcePath / "extraspec_incorrect"
    expectedUpdate(correctPath, true, true)
    expectedUpdate(incorrectPath, false, true)
    expectedUpdate(correctPath, true, false)
    expectedUpdate(incorrectPath, false, false)
  }

  def expectedUpdate(path: Path, shouldVerify: Boolean, BAPVariant: Boolean): Unit = {
    val examples = os.list(path).filter(os.isDir)
    for (e <- examples) {
      val variations = os.list(e).filter(os.isDir)
      for (v <- variations) {
        val name = e.last
        val suffix = if (BAPVariant) {
          "_bap"
        } else {
          "_gtirb"
        }
        val expectedSuffix = if (BAPVariant) {
          ""
        } else {
          "_gtirb"
        }
        val outPath = v / (name + suffix + ".bpl")
        val expectedPath = v / (name + expectedSuffix + ".expected")
        val resultPath = v / (name + suffix + "_result.txt")
        if (os.exists(resultPath)) {
          val result = os.read(resultPath)
          val verified = result.strip().equals("Boogie program verifier finished with 0 errors")
          if (verified == shouldVerify) {
            if (os.exists(outPath) && !(os.exists(expectedPath) && filesContentEqual(outPath, expectedPath))) {
              println(s"updated $expectedPath")
              os.copy.over(outPath, expectedPath)
            }
          }
        }
      }
    }
  }

  def filesContentEqual(path1: Path, path2: Path): Boolean = {
    os.read.lines(path1) == os.read.lines(path2)
  }

  val scalafmt = mill.scalalib.scalafmt.ScalafmtModule


  /**
   * Haoyi: "currently there isn't a terribly easy way to run things sequentially,
   *         but a command taking Evaluator could do that
   *         e.g. https://github.com/com-lihaoyi/mill/discussions/5360"
   */
  def fmt(ev: mill.eval.Evaluator): Command[Unit] = Task.Command(exclusive = true) {
    mill.main.RunScript.evaluateNamed(ev, Agg(fix()))
    mill.main.RunScript.evaluateNamed(ev, Agg(test.fix()))
    mill.main.RunScript.evaluateNamed(ev, Agg(scalafmt.reformat()))
    ()
  }


  object basilAntlr extends AntlrModule {
    override def ivyDeps = Agg(build.antlrRuntime)
    override def antlrPackage = Some("Parsers")
    override def antlrGenerateVisitor = true
    override def antlrGrammarSources = Task.Sources {
      Seq(PathRef(build.millSourcePath / "main" / "antlr4"))
    }
  }

  object basilProto extends ScalaPBModule {
    override def scalaPBVersion = "0.11.15"

    override def scalaVersion = build.scalaVersion
    override def ivyDeps = Agg(build.scalapb)

    override def scalaPBSources = Task.Sources {
      Seq(PathRef(build.millSourcePath / "main" / "protobuf"))
    }

    def scalaDocOptions = Task {
      super.scalaDocOptions() ++ build.scalaDocExternalMappingOptions()
    }
  }

  object bnfc extends BNFCJFlexModule {
    override def bnfcPackageName = "basil_ir"
    override def bnfcExtraArgs = Seq("--line-numbers")
    override def bnfcSource = Task.Source {
      PathRef(build.millSourcePath / "main" / "bnfc" / "BasilIR.cf")
    }
    override def javadocOptions = Task {
      super.javadocOptions() ++ Seq(
        "-linkoffline",
        s"$baseUrl/api/java-cup",
        cup.docJar().path / ".." / "javadoc"
      ).map(_.toString)
    }
  }

  object mdbook extends mdbookBinary {
    def mdbookSources = Task.Source {
      Task.workspace  / "docs"
    }
  }

  object z3 extends Z3Module

  def ctagsConfig = Task.Source {
    Task.workspace / "basilmill" / "scala.ctags"
  }

  /**
   * Build the ctags file containing code definition locations.
   * This can be used with `./mill -w` to watch and re-build on file changes.
   */
  def ctags = Task {
    val src = Task.traverse(Seq(this, test) ++ moduleDeps)(_.allSources)().flatten
    val srcArgs = src.map(_.path).filter(os.exists(_)).map(_.toString)

    val newFile = Task.workspace / "tags.new"
    val tagsFile = Task.workspace / "tags"

    val args = Seq(
      "ctags", "--tag-relative=no", "-R", "-f", newFile.toString,
      "--options=" + ctagsConfig().path,
      "--languages=scala,java", "--fields=+zK")

    os.call(args ++ srcArgs, cwd = Task.workspace)
    os.move(newFile, tagsFile, replaceExisting = true, atomicMove = true)
  }

  object asyncProf extends ProfileModule {
    override def scalaVersion = build.scalaVersion
  }

  def runProfile(profileDest: String, args: String*) = Task.Command {
    println(s"Profiling: you may want to set\n  sudo sysctl kernel.perf_event_paranoid=1\n  sudo sysctl kernel.kptr_restrict=0\n")
    val prof = asyncProf.path()
    os.call(("java", s"-agentpath:${prof}=start,event=cpu,file=${profileDest}",  "-jar", assembly().path.toString, args), stdout = os.Inherit, cwd = Task.workspace)
  }

}
