package build
import mill._
import scalalib._
import scala.util.{Try, Success, Failure}

import os.Path
import $ivy.`com.lihaoyi::mill-contrib-scalapblib:$MILL_VERSION`
import $ivy.`net.mlbox::mill-antlr:0.1.0`
import contrib.scalapblib._

object `package` extends RootModule with ScalaModule with antlr.AntlrModule with ScalaPBModule {
  // ammoniteVersion should be updated whenever scalaVersion is changed. see, for example,
  // https://mvnrepository.com/artifact/com.lihaoyi/ammonite_3.4.3 to list valid versions.
  def scalaVersion = "3.3.4"

  def moduleDeps = Seq(bnfc)

  val ammonite = "3.0.2"
  override def ammoniteVersion = ammonite

  def scalacOptions: T[Seq[String]] = Seq("-deprecation")

  val javaTests = ivy"com.novocode:junit-interface:0.11"
  val scalaTests = ivy"org.scalatest::scalatest:3.2.19"
  val scalaCheck = ivy"org.scalatestplus::scalacheck-1-18:3.2.19.0"
  val scalactic = ivy"org.scalactic::scalactic:3.2.19"
  val antlrRuntime = ivy"org.antlr:antlr4-runtime:4.9"
  val sourceCode = ivy"com.lihaoyi::sourcecode:0.3.0"
  val mainArgs = ivy"com.lihaoyi::mainargs:0.5.1"
  val sprayJson = ivy"io.spray::spray-json:1.3.6"
  val scalapb = ivy"com.thesamet.scalapb::scalapb-runtime:0.11.15"
  val scalaCompiler = ivy"org.scala-lang::scala3-compiler:3.3.4"
  val upickle = ivy"com.lihaoyi::upickle:4.2.1"

  def scalaPBVersion = "0.11.15"

  def mainClass = Some("Main")

  override def scalaPBSources = Task.Sources {
    Seq(PathRef(this.millSourcePath / "main" / "protobuf"))
  }
  def millSourcePath = super.millSourcePath / "src"
  def ivyDeps = Agg(scalactic, antlrRuntime, sourceCode, mainArgs, scalapb, scalaCompiler, upickle)
  def sources = Task.Sources {
    Seq(PathRef(this.millSourcePath / "main" / "scala"))
  }

  override def antlrPackage: Option[String] = Some("Parsers")
  override def antlrGenerateVisitor = true
  override def antlrGrammarSources = Task.Sources {
    Seq(PathRef(millSourcePath / "main" / "antlr4"))
  }

  object test extends ScalaTests with TestModule.ScalaTest {
    override def ammoniteVersion = ammonite
    def ivyDeps = Agg(scalaTests, scalaCheck, javaTests)
    def sources = Task.Sources {
      Seq(PathRef(this.millSourcePath / "scala"))
    }
  }

  /** Updates the expected
    */

  def updateExpectedBAP() = Task.Command {
    val correctPath = test.millSourcePath / "correct"
    val incorrectPath = test.millSourcePath / "incorrect"

    expectedUpdate(correctPath, true, true)
    expectedUpdate(incorrectPath, false, true)
  }

  def updateExpectedGTIRB() = Task.Command {
    val correctPath = test.millSourcePath / "correct"
    val incorrectPath = test.millSourcePath / "incorrect"

    expectedUpdate(correctPath, true, false)
    expectedUpdate(incorrectPath, false, false)
  }

  def updateExpectedExtraSpec() = Task.Command {
    val correctPath = test.millSourcePath / "extraspec_correct"
    val incorrectPath = test.millSourcePath / "extraspec_incorrect"
    expectedUpdate(correctPath, true, true)
    expectedUpdate(incorrectPath, false, true)
    expectedUpdate(correctPath, true, false)
    expectedUpdate(incorrectPath, false, false)
  }

  def expectedUpdate(path: Path, shouldVerify: Boolean, BAPVariant: Boolean): Unit = {
    val examples = os.list(path).filter(os.isDir)
    for (e <- examples) {
      val variations = os.list(e).filter(os.isDir)
      for (v <- variations) {
        val name = e.last
        val suffix = if (BAPVariant) {
          "_bap"
        } else {
          "_gtirb"
        }
        val expectedSuffix = if (BAPVariant) {
          ""
        } else {
          "_gtirb"
        }
        val outPath = v / (name + suffix + ".bpl")
        val expectedPath = v / (name + expectedSuffix + ".expected")
        val resultPath = v / (name + suffix + "_result.txt")
        if (os.exists(resultPath)) {
          val result = os.read(resultPath)
          val verified = result.strip().equals("Boogie program verifier finished with 0 errors")
          if (verified == shouldVerify) {
            if (os.exists(outPath) && !(os.exists(expectedPath) && filesContentEqual(outPath, expectedPath))) {
              println(s"updated $expectedPath")
              os.copy.over(outPath, expectedPath)
            }
          }
        }
      }
    }
  }

  def filesContentEqual(path1: Path, path2: Path): Boolean = {
    os.read.lines(path1) == os.read.lines(path2)
  }

  def scalafmt = mill.scalalib.scalafmt.ScalafmtModule

  def bnfcSource = Task.Source {
    this.millSourcePath / "main" / "bnfc" / "BasilIR.cf"
  }

  val bnfc = new BNFCModule("basil_ir", bnfcSource)

  class BNFCModule(packageName: String, bnfcSource: Task[PathRef], extraArgs: Seq[String] = Nil) extends JavaModule with antlr.AntlrModule {

    override def antlrPackage = Some(packageName)

    override def sources = Task.Sources {
      Seq(bnfcGenerated())
    }
    def antlrGrammarSources = sources
    def ivyDeps = Agg(antlrRuntime)

    private def bnfcDownload(dest: Path): String = {
      val osName = System.getProperty("os.name")
      val suffix = if (osName.contains("nux")) {
        "-linux.binary"
      } else if (osName.contains("Mac")) {
        "-mac.binary"
      } else if (osName.startsWith("Windows")) {
        ".exe"
      }

      // https://github.com/BNFC/bnfc/releases
      val version = "2.9.5"
      val url = s"https://github.com/BNFC/bnfc/releases/download/v$version/bnfc-$version$suffix"
      val p = dest / s"bnfc-binary-${System.currentTimeMillis()}"
      os.write(p, requests.get(url))
      os.perms.set(p, "rwxr-xr-x")
      p.toString
    }

    def bnfcLocal = Task.Input {
      Try(os.proc("bnfc", "--version").call())
        .map(_.out.trim())
        .toEither
        .left.map(_.toString)
    }

    def bnfcBinary = Task {
      bnfcLocal().getOrElse(bnfcDownload(Task.dest))
    }

    /**
     * Runs the BNFC binary.
     */
    override def run(args: Task[Args] = Task.Anon(Args())) = Task.Command {
      val res = os.call(bnfcBinary() +: args().value, stdout = os.Inherit, check = false)
      Task.ctx().systemExit(res.exitCode)
      ()
    }

    def bnfcGenerated = Task {
      val args = Seq("--java-antlr", bnfcSource().path.toString, "-m", "-o", Task.dest.toString)
      os.call(bnfcBinary() +: (args ++ extraArgs))
      PathRef(Task.dest)
    }
  }
}
